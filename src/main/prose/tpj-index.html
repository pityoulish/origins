<html>
<!-- 
This work is released into the Public Domain under the
terms of the Creative Commons CC0 1.0 Universal license.
https://creativecommons.org/publicdomain/zero/1.0/
-->
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="pityoulish.css" />
<title>Tutorial: Prepare for Java Exercises </title>
</head>
<body>
<h1 id="tutorial" class="title">
  <span>Tutorial: Prepare for Java Exercises</span>
</h1>
<p class="abstract">
After completing this tutorial, you are familiar with the structure of the
upcoming Java classroom exercises. You know how to perform the required
development procedures in your preferred development environment.
</p>

<div class="larger">
This tutorial comprises three phases:
<dl>
  <dt>1. <a href="#run-jar">Run the JAR</a></dt>
  <dd>
    You execute the provided, runnable JAR to understand
    what it is supposed to do, and what is wrong with it.
  </dd>

  <dt>2. <a href="#study-source">Study the Sources</a></dt>
  <dd>
    You look at the provided JavaDocs and source files
    to find your way through the code.
  </dd>

  <dt>3. <a href="#fix-problems">Fix the Problems</a></dt>
  <dd>
    You fix the source code and build your own, working JAR from it.
  </dd>
</dl>
The <a href="#summary">summary</a> outlines the steps you performed
in order to complete the tutorial. At the same time, it provides
a recipe to follow when working on a Java classroom exercise.

Last but not least, there is some information about the
<a href="#msgboard">upcoming</a> exercises.
Reading it upfront will give you a head start.
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="run-jar"><span>Run the JAR</span></h2>

<div class="box-right">
<dl>
<dt><a href="tutorial-faulty.jar"><code>tutorial-faulty.jar</code></a></dt>
<dd>The program to test and fix. Usage instructions:
  <br/><code>&nbsp;&nbsp;java -jar tutorial-faulty.jar</code><br/>
  Sources are in the jar, <a href="jdoc/index.html">docs</a> here.
</dd>
</dl>
</div><!-- box-right -->

<p>
First verify that a Java Virtual Machine (JVM) or
Java Development Kit (JDK) is available on your computer.
Open a command line and enter:
</p>
<div class="terminal">
  <div class="input"><span>java -version</span></div>
</div>
<p>
Version 1.7 or later is needed. If the <code>java</code> command is not found,
you have to investigate why. Most likely it is just missing from the
search path. Locate an installed JVM or JDK and add its <code>bin</code>
directory to the <code>PATH</code> environment variable,
or use the full path to run <code>java</code> and related utilities.
If there is neither JVM nor JDK, install a JDK. You'll need it later anyway.
How to do that depends on your operating system and the JDK you want to use.
<!-- @@@ TODO: warn about the adware installed by Oracle on Windows? -->
<!-- @@@ TODO: Extra page with instructions for installing a JDK? -->
</p>

<p>
Now download the file
<a href="tutorial-faulty.jar"><code>tutorial-faulty.jar</code></a>
to your machine. Change to the directory where you saved it and enter:
</p>
<div class="terminal">
  <div class="input"><span>java -jar tutorial-faulty.jar</span></div>
</div>
<p>
This tells <code>java</code> to run the program contained in the JAR file.
Without further arguments, that program just prints usage instructions.
Take a minute to read those.
</p>
<p>
Seriously, read them.
</p>

<p>
So, the program understands several different commands.
Use <code>latin</code> to check whether your environment is ready
to display characters from the ISO Latin 1 character set.
</p>
<div class="terminal">
  <div class="input"><span>java -jar tutorial-faulty.jar latin</span></div>
</div>
<p>
If the output contains umlauts, you're all set. If it contains garbage, or
question marks in unexpected places, you need to do something. The default
character encoding of the JVM does not match that of your command line.
This is a common problem with <code>cmd.exe</code> on Windows.
You can use a different command line, for example the PowerShell,
or figure out how to
<a href="http://illegalargumentexception.blogspot.co.uk/2009/04/i18n-unicode-at-windows-command-prompt.html"
   >fix the problem</a>.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="test-commands"><span>Test the Commands</span></h3>

<p>
The downloaded JAR supports three more commands besides <code>latin</code>.
They cover the technical contents of this tutorial: IP addresses and hostnames.
Let's try them one after another, starting with <code>local</code>.
</p>
<div class="terminal">
  <div class="input"><span>java -jar tutorial-faulty.jar local</span></div>
  <div class="output"
>Network Interface 'wlan0'
   fe80:0:0:0:fc5a:73ee:fe85:733c%3
   10.223.123.161
Network Interface 'lo'
   0:0:0:0:0:0:0:1%1   ip6-localhost
   127.0.0.1   localhost</div>
</div>
<p>
The output is different on each machine and depends on the available
network connections. In the example, the machine is connected to a WLAN,
'wlan0'. The local interface, 'lo', is always present. It enables programs
that run on the same machine to communicate with eachother, even if
there is no actual network connection. The machine from the example
has both an IPv4 and an IPv6 address on either network interface.
Does yours?
</p>

<p>
The remaining two commands expect an argument, which can be a hostname or
an IP address. The usage instructions only mention hostnames, but all
operating systems are smart enough to handle IP addresses as well.
Let's try both commands with 'localhost' as the argument.
</p>
<div class="terminal">
  <div class="input"><span>java -jar tutorial-faulty.jar islocal localhost</span></div>
  <div class="output"
>Exception in thread "main" <span class="emph">pityoulish.outtake.Missing</span>: bind a socket to a hostname
	at ...</div>
  <div class="input"><span>java -jar tutorial-faulty.jar lookup localhost</span></div>
  <div class="output"
>Looking up 'localhost'...
Exception in thread "main" <span class="emph">pityoulish.outtake.Missing</span>: look up the InetAddress(es) of a hostname
	at ...</div>
</div>

<p>
Dang! Both commands are broken. Well, there had to be a reason why the JAR
is called 'faulty'. The class of the exception,
<code>pityoulish.outtake.Missing</code>, indicates that something was
intentionally left out of the program. And you are expected to fill it in.
If you see other exceptions, they indicate actual problems.
You'll have to interpret the exception messages.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="study-source"><span>Study the Sources</span></h2>

<p>
Before you proceed, rename the downloaded JAR to <code>tutorial.jar</code>
or some other name without negative connotation.
While it is faulty now, it won't be when you're done with it.
Renaming the file helps you to maintain a positive mindset.
</p>

<p>
List the contents of the JAR file.
Use the <code title="jar -tf">jar</code> utility of a JDK,
or <code title="unzip -l">unzip</code>,
or any other archive utility that is compatible with the zip format.
The example output below shows only a subset of the files.
</p>
<div class="terminal">
  <div class="input"><span>jar -tf tutorial.jar</span></div>
  <div class="output"
>META-INF/MANIFEST.MF
pityoulish/cmdline/ArgsInterpreter.java
...
pityoulish/outtake/<span class="emph">Missing.java</span>
pityoulish/outtake/package.html
pityoulish/tutorial/Main.java
pityoulish/tutorial/TutorialCommandHandler.java
pityoulish/cmdline/ArgsInterpreter.class
...
pityoulish/outtake/<span class="emph">Missing.class</span>
pityoulish/tutorial/Main.class
...
pityoulish/tutorial/TutorialCommandHandler.class
</div>
</div>
<p>
On first glance, it seems as if classes are listed twice. Indeed,
a closer look reveals that the JAR contains source code (.java)
along with compiled classes (.class). The presence of 'package.html' files
even suggests that there might be meaningful JavaDocs.
It is always possible to generate JavaDocs from source code.
But if the source code doesn't contain special JavaDoc comments,
the generated docs are not always useful. Alas, the mere presence of
JavaDoc comments also doesn't ensure that they contain anything useful.
Fortunately, this is a tutorial with well-documented source code.
</p>

<p>
If you plan to use an Integrated Development Environment (IDE) for coding,
now is a good time to import <code>tutorial.jar</code> as a new project.
There are many IDEs that support Java development, for example
<a href="https://www.jetbrains.com/idea/"
   title="IntelliJ IDEA - Community Edition"
   >IntelliJ</a>,
<a href="https://www.eclipse.org/downloads/"
   title="Eclipse IDE for Java Developers"
   >Eclipse</a>,
<a href="https://code.visualstudio.com/"
   title="Visual Studio Code"
   >Visual Studio Code</a>, or
<a href="https://netbeans.org/downloads/index.html"
   title="NetBeans - Java SE"
   >NetBeans</a>.

However, you don't need an IDE to complete this tutorial,
or the upcoming programming exercises.
Just use the archiver from above to extract the files from the JAR, and your
<a href="https://en.wikipedia.org/wiki/Editor_war" class="covert"
   >favorite editor</a>
to browse them.
Make sure to maintain the directory structure when extracting though.
</p>
<!-- doesn't add much value and looks crappy above the h3
<div class="terminal">
  <div class="input"><span>jar -xf tutorial.jar</span></div>
</div>
-->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="jdoc-walk-through"><span>JavaDoc Walk-Through</span></h3>

<p>
Before you dive into the source code and get lost in its intricacies,
you should get a high-level overview. Modern IDEs make it very easy to
access context-specific information. For example, they can show the JavaDocs
for a method as hover help, right there where the method is being called.
At the same time, they beguile users into neglecting the bigger context.
Why bother with the class- or package-level JavaDocs when the method-level
is readily available? Never mind that the former might point out
other classes or methods that would serve your purposes better, or
provide valuable information that applies to all the methods of a class.
To avoid this pitfall, don't go into your IDE or editor just yet.
</p>

<p>
Open the <a href="jdoc/index.html">JavaDocs</a> in a new browser tab or window,
so you can easily switch between them and this description.
Check the list of packages. There are only two,
<code>pityoulish.cmdline</code> and <code>pityoulish.tutorial</code>.
In the main content frame, click on the first one. Now you see a list of
interfaces and classes in that package. Glimpse at the names. They are
about commands, handling, and arguments. The package description begins
with "Utility classes". This indicates that the package does not contain
the main functionality of the program, but supporting features.
Are you interested in learning how the command-line arguments are interpreted?
If so, write it down on your to-do list for later.
Right now, the support functionality is not your concern.
</p>

<p>
Next, access the JavaDocs for the <code>pityoulish.tutorial</code> package.
There is a class <code>Main</code>, described as the main entry point.
Now you know where to start. There is an enum with four constants,
named like the four commands which <code>tutorial.jar</code> understands.
And there is a handler class with methods named like the four commands.
Could <code>handleLatinCmd</code> be the method which prints the umlauts
of the 'latin' command? Yes, the description says so.
Without even looking at the source code, you've learned where the
important things are happening.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="source-walk-through"><span>Source Code Walk-Through</span></h3>

<p>
Now it is time to browse the source code. If you didn't know already
from the JavaDocs where to start, you would have to look into the file
<code>META-INF/MANIFEST.MF</code>. It defines a property 'Main-Class',
which tells <code>java -jar</code> about the entry point of the program.
Unsurprisingly, the value is <code>pityoulish.tutorial.Main</code>.
Open the source file for that class in your IDE or editor
and find the method <code>main</code>.
</p>

<p>
The <code>main</code> method initializes an arg(ument)s interpreter,
calls it with the command-line arguments, and is done.
If you hadn't looked at the JavaDocs first, you would now probably
follow the program execution and look into the args interpreter.
However, you already know that it comes from a utility package, and that
the commands are implemented in <code>TutorialCommandHandler</code>.
An instance of that class is given to the args interpreter as a
constructor argument. The other constructor argument is some kind of 'None',
so probably not relevant here. The natural conclusion is that
the args interpreter will call the command handler.
Let's go directly to the latter, without wasting time on the former.
</p>

<p>
Looking at <code>TutorialCommandHandler</code>, you see the enumeration of
supported commands, a method that returns usage instructions, and a method
with a <code>switch</code> statement on the enum. Each case of that statement
calls a handler method for the respective command.
Whatever else the args interpreter does, it calls here to execute a command.
That's what you needed to know to get started.
</p>


<div class="box-center">
<span class="header">
<span class="title">Word of Advice</span>
<span class="abstract"
      >Badly structured code invalidates natural conclusions.</span>
</span><!-- header -->
<span class="content">
When you are diving into any codebase of significant size, it is
impossible to understand every part of it to the very last detail.
In order to find the code of interest within a reasonable time,
you absolutely <span class="emph">must</span> make assumptions
about other parts of the code.

In a well-structured codebase, classes and modules behave roughly as
you would expect from their names or descriptions. This is called the
<a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment"
   >Principle of Least Astonishment (POLA)</a>.
It greatly simplifies the task of getting to know a codebase
and reduces the time you need to become productive.
<br/>

In ill-structured code, such assumptions will not hold.
Classes or modules do things you wouldn't expect, and
things you do expect are not done where you expect them.
You'll spend a lot of time searching for why something is happening,
until you find the cause hidden away in an inconspicuous module.
Or you'll read through some code and see that it is doing
completely unrelated things as well.
These moments of realization are called WTFs. In fact,
<a href="http://www.osnews.com/story/19266/WTFs_m">WTFs per minute</a>
are considered a measurement of code quality.
For a regular stream of bad examples, see
<a class="covert" href="http://thedailywtf.com/">The Daily WTF</a>.
</span>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="fix-problems"><span>Fix the Problems</span></h2>

<p>
There are two broken commands to fix in this tutorial.
The following instructions for the <a href="#fix-islocal">first</a>
are very detailed.
Those for the <a href="#fix-lookup">second</a> remain brief,
so you can start to apply what you learned.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="fix-islocal"><span>Fix the <code>islocal</code> Command</span></h3>

<p>
Call the command again, to have a closer look at the error message
and the stack trace. Details such as line numbers probably differ
from the example output. Work with what you see on your screen,
because that matches with the source code in your JAR.
</p>
<div class="terminal">
  <div class="input"><span>java -jar tutorial.jar islocal localhost</span></div>
  <div class="output"
>Exception in thread "main" pityoulish.outtake.Missing: <span class="emph">bind a socket to a hostname</span>
	at pityoulish.outtake.Missing.here(Missing.java:31)
	at pityoulish.tutorial.TutorialCommandHandler.<span class="emph">handleIsLocalCmd(TutorialCommandHandler.java:159)</span>
	at pityoulish.tutorial.TutorialCommandHandler.handleCommand(TutorialCommandHandler.java:92)
	at pityoulish.tutorial.TutorialCommandHandler.handleCommand(TutorialCommandHandler.java:26)
	at pityoulish.cmdline.CommandHandlerBase.handle(CommandHandlerBase.java:76)
	at pityoulish.cmdline.ArgsInterpreter.handle(ArgsInterpreter.java:88)
	at pityoulish.tutorial.Main.main(Main.java:27)
</div>
</div>


<!-- ............................................................ -->
<div class="side-note"><div class="content">
<span>Interpret the Stack Trace</span>
</div></div>

<p>
The first line reveals the class of the exception, and an exception message.
The class often indicates the type of problem, for example
a <code>NullPointerException</code> or an <code>IOException</code>.
In this case, some code is missing; you already know that.
The message tells you what the missing code is supposed to do.
We'll get to that later, once you've found where it is missing.
</p>
<p>
The lines starting with "at" are the call stack.
The program execution started at <code>main</code>, which is the last line.
<code>main</code> called <code>ArgsInterpreter.handle</code>,
which called <code>CommandHandlerBase.handle</code>,
which called something else, and so on,
right up to <code>Missing.here</code> at the top of the stack.
And there, the exception was thrown. In parenthesis, you see
the source file name 'Missing.java' and a line number.
Open the file and find the line number indicated by your stack trace.
If you executed the command from within an IDE,
you probably just have to click a link in the output.
Now what is wrong in <code>here</code>?
</p>

<p>
Well, nothing is wrong in <code>Missing.here</code>.
It is a helper method meant to throw an exception, and so it does.
The caller must have found that something is wrong
and raised an exception by invoking the helper.
You need to find the place from which it is being called.
Luckily, the second line of the stack trace tells you exactly that.
Load the file 'TutorialCommandHandler.java' and
have a look at method <code>handleIsLocalCmd</code>,
especially around the line number from your stack trace.
</p>
<div class="code">
  Missing.here("bind a socket to a hostname");
  Missing.pretend(IOException.class);
</div>


<!-- ............................................................ -->
<div class="side-note"><div class="content">
<span>Analyze <!--and Fix--> the Problem</span>
</div></div>

<!--
<p>
</p>
-->

<p class="larger"><i>Instructions still missing...</i></p>
<ol>
  <li>What data is available, what is expected?</li>
  <li>Search the standard JavaDocs for matching methods.</li>
  <li>Add the missing code in the sources.</li>
</ol>


<!-- ............................................................ -->
<div class="side-note"><div class="content">
<span>Build the JAR</span>
</div></div>

<p class="larger"><i>Instructions still missing...</i></p>
<ol>
<li>compile the sources, build a new JAR</li>
<li>run the new JAR, in command line or from IDE</li>
<li>make sure <code>java -jar</code> works
  <br/>
  ...or else type the full name of the Main class on each invocation</li>
<li>test the fix</li>
</ol>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="fix-lookup"><span>Fix the <code>lookup</code> Command</span></h3>

<ol>
<li>call the second faulty command
  <br/>
  (repeat steps from above, with less details)</li>
</ol>

<!-- examples for the 'lookup' command, 2015-12-13:
gnu.org    -> single IPv4 address
apache.org -> two different IPv4 addresses
fsf.org    -> IPv4 and IPv6 addresses
-->


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h1 id="summary"><span>Summary</span></h1>

<p class="larger"><i>Generic steps for a classroom exercise...</i></p>
<ol>
<li>get the JAR and read the usage instructions</li>
<li>determine the sequence of commands to try out
  <br/>
  In the tutorial, the commands are independent. In the programming exercises,
  a user will execute commands in a specific order to achieve a purpose.
  Construct a <i>user session</i>, a series of commands to run.
</li>
<li>run the command sequence until you find a broken command</li>
<li>study the JavaDocs, study the sources</li>
<li>jump to the broken command, identify the context, insert missing code</li>
<li>create a new JAR and re-run the command sequence</li>
<li>when you can execute a sequence that covers all commands, you're done</li>
</ol>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h1 id="msgboard"><span>Coming up...</span></h1>

<p>
  In the classroom exercises, you'll be facing a server which
  implements the <a href="message-board.html">Message Board</a>.
  Better read that description now.
</p>

</body>
</html>

