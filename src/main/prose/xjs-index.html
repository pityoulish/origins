<html>
<!-- 
This work is released into the Public Domain under the
terms of the Creative Commons CC0 1.0 Universal license.
https://creativecommons.org/publicdomain/zero/1.0/
-->
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="pityoulish.css" />
<title>Exercise: Message Board Client with Sockets </title>
</head>
<body>
<h1 id="exercise" class="title">
  <span>Exercise: Message Board Client with Sockets</span>
</h1>
<p class="abstract">
During this exercise, you will get a glimpse of what it means to
implement a low-level protocol interface on top of socket connections.
</p>

<div class="larger">
<p>
Your task is to find and fix errors in a Java client program.
The client communicates with a <a href="message-board.html">Message Board</a>
server using a <a href="protocol-tlv.html">Binary Protocol</a>.
The server is operated by the instructor.
The client, when fixed, enables you to put messages on the board,
and to read the messages others have put there.
</p>

<p>
A recipe for solving this task has been conveyed beforehand in a Tutorial.
If you failed to complete the Tutorial, you're probably screwed now.
Instructions below recap the major steps just briefly.
The sections appear in chronological order, more or less:
</p>

<ol>
<li><a href="#setup">Setup</a> before you begin</li>
<li><a href="#sequence">Define</a> a test sequence</li>
<li><a href="#testfixbuild">Test, Fix, Build</a>, repeat</li>
<li><a href="#code">Code Overview</a> for fixing</li>
<li><a href="#learned">Lessons Learned</a> when done</li>
</ol>

</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="setup"><span>Setup</span></h2>
<!--h2 id="prepare"><span>Prepare</span></h2-->

<p>
You already set up a Java development environment in the Tutorial.
Editor, Java compiler and tools, maybe an IDE, are readily available.
Good.
</p>

<p>
You already know how to access the instructions for this exercise,
because you're reading them. Good.
Other useful things you could open in separate browser tabs are
the Java Platform API specification (aka standard JavaDocs)
and the Tutorial instructions.
Where to find either depends on the network setup.
</p>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="connectivity"><span>Network</span></h3>

<p>
Connect your computer to the network with the server, if you have not
done so already. The instructor provides all necessary information,
along with the following:
</p>
<ul>
<li>IP address and port number of the Message Board server.
  A hostname may replace the IP address.</li>
<li>URL to the Java Platform API JavaDocs,
  if the network is isolated from the Internet.</li>
<li>URL to this exercise, optionally.</li>
<li>URL to the Tutorial, optionally.</li>
</ul>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h3 id="client"><span>Client</span></h3>

<div class="box-right">
<dl>
<dt><a href="mbclient-sockets-faulty.jar"
       ><code>mbclient-sockets-faulty.jar</code></a></dt>
<dd>The program to test and fix. Usage instructions:
  <br/><code>&nbsp;&nbsp;java -jar mbclient-sockets-faulty.jar</code><br/>
  Sources are in the jar,
  <a href="jdoc/index.html" target="_blank">docs</a> here.
</dd>
</dl>
</div><!-- box-right -->

<p>
Download the client, <a href="mbclient-sockets-faulty.jar"
                        ><code>mbclient-sockets-faulty.jar</code></a>,
and give it a decent filename.
Remember how important it is to keep a positive mindset:
<i>You will extirpate all faultiness.</i>
Start with the filename.
</p>

<p>
Run the client without arguments to obtain the usage instructions.
Read and understand those.
If you haven't done so already, read the high-level description
of the <a href="message-board.html">Message Board</a> now.
You will notice that the commands supported by the client
match with the operations defined for a Message Board.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="sequence"><span>Define a Test Sequence</span></h2>

<p>
Some commands of the client depend upon others.
For example, putting a message on the board depends on obtaining a ticket.
And listing messages starting at a marker depends on
getting a marker from a previous listing.
Testing the full client functionality therefore requires execution of all
commands in a logical sequence. Commands with different possible arguments,
or with different possible results, should be covered in all variations.
</p>

<p>
In practice, defining test cases which thoroughly cover a program or API
requires good knowledge of that program or API, and some experience.
To get you started with this exercise,
you may use the following test sequence:
</p>
<ol>
<li>
List messages from the board, without marker.
</li>
<li>
Obtain a ticket.
</li>
<li>
Put some messages on the board.
</li>
<li>
List messages again, with and without marker.
Use different markers.
</li>
<li>
Return a ticket.
Use it again afterwards, to verify that it is no longer valid.
</li>
<li>
Replace a ticket, before and after exhausting all operations.
</li>
</ol>

<p>
That sequence covers only a few of the error cases, but that is sufficient
for the exercise. You don't have to test for invalid arguments, for example.
Not knowing for how long a ticket is valid, or how many operations it permits,
will confront you with enough error situations to get into the spirit.
</p>

<p>
That sequence is also missing some good cases.
You may encounter them perchance, but they are not enforced.
See if you can spot those gaps in the test coverage throughout the exercise.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="testfixbuild"><span>Test, Fix, Build, repeat</span></h2>

<p>
Start executing the test sequence, from the command line or your IDE.
Be prepared to deal with problems such as typos in command-line arguments,
incorrect usage of the client, network connectivity issues, and the like.
Resolve them and move on with the test sequence, until you
encounter a <code>pityoulish.outtake.Missing</code> exception.
</p>

<p>
As you remember from the Tutorial, that exception marks an intentional
omission from the code. Don't start fixing yet!
The first time you encounter the exception, make sure to
get a <a href="#code">Code Overview</a>
from the <a href="jdoc/index.html" target="_blank">JavaDocs</a>
before you dive into the sources.
</p>

<p>
OK, you've got a general understanding of the packages and classes
from the JavaDocs now. You found the classes from the stack trace there.
It's time to hit the source code, which is included in the JAR.
Locate where the exception is raised, where some code is missing.
Then stop to <b
title="If you invoke the auto-completion of your IDE and pick the
first method with a comely name, you're doing something wrong."
                >think</b>.
</p>

<!-- ............................................................ -->
<div class="side-note"><div class="content">
<span>Think!</span>
</div></div>

<ul>
<li>
What is the missing code supposed to do?
There is an exception message, maybe some comment in the source code,
JavaDocs of the method.
</li>
<li>
What data do you need? What data is available?
Look at local variables, method arguments, object attributes,
getters in the class hierarchy.
</li>
<li>
If you have to generate or parse binary data for or from the server,
refer to the <a href="protocol-tlv.html">Binary Protocol</a> specification.
</li>
<li>
How can you solve the problem?
Is there a standard API to use, or something in the client code?
</li>
<li>
Where can you copy from?
Are there other places in the client that do something similar?
It's OK to re-use code snippets from there.
</li>
</ul>

<p>
Remove the call that raises the exception and fill in the missing code.
Compile the sources and build a new JAR that includes your fix.
Repeat the failing step of the test sequence,
and prerequisite steps if necessary.
If your fix is good, proceed with the test sequence.
If not, improve your fix.
</p>

<p>
After completing the test sequence, perform the final cleanup.
Delete the package <code>pityoulish.outtake</code>, both source and classes.
Delete the <code>.class</code> files from all other packages.
Then compile the whole client from source code again.
Fix compilation problems, and then you're done.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="code"><span>Code Overview</span></h2>

<p>
Open the <a href="jdoc/index.html" target="_blank">JavaDocs</a> for the client
and look at the list of packages. Two of them,
<code>pityoulish.cmdline</code> and <code>pityoulish.i18n</code>,
are the same as in the Tutorial. There's no need to look at them now.
The other two are specific to the Message Board with sockets.
In <code>pityoulish.sockets.client</code>, you will apparently find the client.
The TLV utility classes in <code>pityoulish.sockets.tlv</code> are
needed by client and server alike, therefore the extra package.
</p>

<p>
Select package <code>pityoulish.sockets.client</code>
and look at the interfaces.
Two of them are called <code>Handler</code>, and you remember that term
from the Tutorial. The <code>MsgBoardClientHandler</code>
has one method for each command that the client supports.
The arguments match those that are expected on the command line.
But there is nothing about a hostname or port to connect to.
Move on to <code>SocketBackendHandler</code>.
That's where those parameters are taken care of.
The purposes of <code>RequestBuilder</code> and <code>ResponseParser</code>
are obvious from their name, although the latter does something funny
with a <code>Visitor</code>.
Never mind that detail now - you must get an <i>Overview</i>.
</p>

<p>
Now look at where the handlers are implemented.
There is a single class for <code>SocketBackendHandler</code>, that's easy.
For <code>MsgBoardClientHandler</code>, there is a <code>Base</code> and
an <code>Impl</code> class.
The base class has attributes for several helper objects.
It implements all methods of the interface, but defines an abstract method
to fire requests. The abstract method gets a binary request as argument.
That means the base class uses its <code>RequestBuilder</code> to map
all the commands of the client to that abstract method.
The impl class implements the abstract method, and has extra methods
for sending requests and reading responses.
Those expect a socket as argument, so here you found the IO logic.
</p>

<p>
That's enough for an overview.
The package-level JavaDocs provide more details, in case you need them.
But from these brief observations, you already know that different classes
are responsible for building requests, parsing responses, and
communicating over socket connections.
The client handler base class ties the helpers together.
The call path from the <code>Main</code> class
through package <code>pityoulish.cmdline</code>
and class <code>MsgBoardCommandDispatcher</code>
into the client handler is of little interest.
</p>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="learned"><span>Lessons Learned</span></h2>

<!-- How much of this here, how much in Instructor's Notes? -->
<ul class="todo">
<li>
Did you get through the full test sequence?
</li>
<li>
Did you find and fix all the problems?
Spotted things not covered by the test sequence?
</li>
<li>
What problems did you encounter?
Besides the errors that you fixed, of course.
</li>
<li>
How do you like coding on this level?
</li>
<li>
Found something in the code that you'd like to improve?
Besides the errors that you fixed, of course.
</li>
<li>
From here...
Want to do some home programming?
Help with the Open Source project?
</li>
</ul>

</body>
</html>

