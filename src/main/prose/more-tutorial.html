<html>
<!-- 
This work is released into the Public Domain under the
terms of the Creative Commons CC0 1.0 Universal license.
https://creativecommons.org/publicdomain/zero/1.0/
-->
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<link rel="stylesheet" type="text/css" href="pityoulish.css" />
<title>Details: Prepare for Java Exercises </title>
</head>
<body>
<h1 id="tutorial-details" class="title">
  <span>Details: Prepare for Java Exercises</span>
</h1>
<p class="abstract">
...
</p>

<div class="larger">
This page collects detailed descriptions and background information for
some parts of the <a href="index.html">Tutorial</a>.
You're not required to read and learn everything noted here.
The Tutorial links to individual sections.
You should <a onclick="history.back();">return</a>
to the Tutorial after each section.
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="jar"><span>JAR Content</span></h2>

<p>
List the contents of the JAR file.
Use the <code title="jar -tf">jar</code> utility of a JDK,
or <code title="unzip -l">unzip</code>,
or any other archive utility that is compatible with the zip format.
The example output below shows only a subset of the files.
</p>
<div class="terminal">
  <div class="input"><span>jar -tf tutorial.jar</span></div>
  <div class="output"
>META-INF/MANIFEST.MF
...
pityoulish/tutorial/Catalog.java
pityoulish/tutorial/CatalogData.properties
pityoulish/tutorial/CatalogData_de.properties
pityoulish/tutorial/<span class="emph">Main.java</span>
pityoulish/tutorial/TutorialCommandHandler.java
pityoulish/tutorial/package.html
...
pityoulish/tutorial/Catalog.class
pityoulish/tutorial/<span class="emph">Main.class</span>
...
</div>
</div>
<p>
There are files of different types in the archive:
</p>
<dl>
<dt><code>META-INF/MANIFEST.MF</code></dt>
<dd>
  The manifest.
  The presence of this file tells the JVM that the archive is actually a JAR.
  In an executable JAR, one entry in the manifest specifies the main class,
  the entry point for the program.
  <br/>
  The <code>META-INF/</code> directory can also be used to store
  non-standard meta information about the JAR, for example a build timestamp.
</dd>
<dt><code>.../*.class</code></dt>
<dd>
  Compiled Java classes.
  The directories correspond to the package structure.
</dd>
<dt><code>.../*.java</code></dt>
<dd>
  Java source code.
  JAR files do not have to contain source code, but those for the exercises do.
  After all, it will be your task to fix bugs in the source code.
</dd>
<dt><code>.../package.html</code></dt>
<dd>
  JavaDoc package descriptions.
  The presence of these files suggest that there might be useful JavaDocs.
  It is always possible to generate JavaDocs from source code.
  But if the source code doesn't contain special JavaDoc comments,
  the generated docs are not necessarily useful. Alas, the mere presence of
  JavaDoc comments also doesn't ensure that they contain anything useful.
  Fortunately, this is a tutorial with well-documented source code.
</dd>
<dt><code>...CatalogData*.properties</code></dt>
<dd>
  Output strings for different languages.
  At runtime, the program uses the default locale of the JVM
  to decide which language to display.
<!--
  Strings for translating the program output into different languages.
  Properties files are used at runtime to look up strings or other values,
  by predefined lookup keys.
  A program that is enabled for translation does not contain output strings,
  but lookup keys instead. The output strings are stored in properties files.
  These properties files can be translated into different languages,
  which are stored in properties files with a similar name that includes
  a language identifier, for example </code>_de</code>.
-->
</dd>
</dl>
<p>
Programs or libraries can also add other resources to a JAR,
for example images, HTML templates, and style sheets needed at runtime.
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="jar-trouble"><span>Troubleshooting your JAR</span></h2>

<p>
This section explains some problems you might run into
when building your own JAR.
</p>

<dl>
<dt>JAR is not executable</dt>
<dd>
<p>
The JAR file contains Java classes, properties files, and a manifest.
The JAR is executable when its manifest specifies an entry point,
which is a classname.
If you are using an IDE, configure class <code>pityoulish.tutorial.Main</code>
as the entry point in the manifest.
If you are using a command line, the entry point is specified
with option '<code>e</code>' of the <code>jar</code> command.
</p>
<p>
When you create a project from a JAR file, your IDE should
read the entry point from the manifest.
But if you create a project from source code in the file system,
your IDE generates a new manifest without an entry point.
</p>
<p>
Instead of creating an executable JAR, you can also specify the classname
when starting the program.
The JAR then has to be put on the classpath with <code>-cp</code>
rather than being executed with <code>-jar</code>:
</p>
<div class="terminal">
  <div class="input"
       ><span>java -cp tutorial.jar pityoulish.tutorial.Main</span></div>
</div>
</dd>

<dt>Output contains <code>CatalogData</code> instead of expected text</dt>
<dd>
<p>
Human-readable text for output is stored in properties files.
These properties files can be translated into different languages
without changing the source code and compiling new classes.
The properties files are part of the source code and
must be available at runtime.
If they are missing, the program will print lookup keys
instead of the texts it cannot look up.
</p>
<p>
If you are running a JAR file, bundle the properties files into the JAR.
<br/>
If you are running the program directly from an IDE project,
add the source directory to the classpath.
</p>
</dd>

<!--
<dt></dt>
<dd>
</dd>
-->
</dl>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="jdoc-walk-through"><span>JavaDoc Walk-Through</span></h3>

<p>
Before you dive into the source code and get lost in its intricacies,
you should get a high-level overview. Modern IDEs make it very easy to
access context-specific information. For example, they can show the JavaDocs
for a method as hover help, right there where the method is being called.
At the same time, they beguile developers into neglecting the bigger context.
Why bother with the class- or package-level JavaDocs, when the method-level
is readily available? Never mind that the former might point out
other classes or methods that would serve your purposes better, or
provide valuable information that applies to all the methods of a class.
To elude this pitfall, don't go into your IDE or editor just yet.
</p>

<p>
Open the <a href="jdoc/index.html" target="_blank">JavaDocs</a>
in a new browser tab or window,
so you can easily switch between them and this description.
Check the list of packages. There are three of them,
<code>pityoulish.cmdline</code>, <code>pityoulish.i18n</code>,
and <code>pityoulish.tutorial</code>.
In the main content frame, click on the first one. Now you see a list of
interfaces and classes in that package. Glimpse at the names. They are
about commands, handling, and arguments. The package description begins
with "Utility classes". This indicates that the package does not contain
the main functionality of the program, but supporting features.
Are you interested in learning how the command-line arguments are interpreted?
If so, write it down on your to-do list for later.
Right now, the support functionality is not your concern.
</p>

<p>
Move on to the next package, <code>pityoulish.i18n</code>.
The funny abbreviation is explained in the JavaDocs. There are even links
to external websites where you can do some background reading.
But again, the package description begins with "Utility classes".
So this is another item for your to-do list and a later time.
What you should gather from the package description is that
output strings are not hard-coded in the Java sources.
Instead, they are looked up from properties files.
Catalog enums define lookup keys and helper methods.
</p>

<p>
Finally, access the JavaDocs for the <code>pityoulish.tutorial</code> package.
There is a class <code>Main</code>, described as the main entry point.
Now you know where to start. There is an enum with four constants,
named like the four commands which <code>tutorial.jar</code> understands.
And there is a handler class with methods named like the four commands.
Could <code>handleLatinCmd</code> be the method which prints the umlauts
for the 'latin' command? Yes, the description says so.
Without even looking at the source code, you've learned where the
important things are happening.
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="source-walk-through"><span>Source Code Walk-Through</span></h3>

<p>
Now it is time to browse the source code. If you didn't know already
from the JavaDocs where to start, you would have to look into the file
<code>META-INF/MANIFEST.MF</code>. It defines a property 'Main-Class',
which tells <code>java -jar</code> about the entry point of the program.
Unsurprisingly, the value is <code>pityoulish.tutorial.Main</code>.
Open the source file for that class in your IDE or editor.
</p>

<p>
The <code>main</code> method initializes an arg(ument)s interpreter,
calls it with the command-line arguments, and is done.
If you hadn't looked at the JavaDocs first, you would now probably
follow the program execution and look into the args interpreter.
However, you already know that it comes from a utility package, and that
the commands are implemented in <code>TutorialCommandHandler</code>.
An instance of that class is given to the args interpreter as a
constructor argument. The other constructor argument is some kind of 'None',
so probably not relevant here. The natural conclusion is that
the args interpreter will call the command handler.
Let's go directly to the latter, without wasting time on the former.
</p>

<p>
Looking at <code>TutorialCommandHandler</code>, you see the enumeration of
supported commands, a method that returns usage instructions, and a method
with a <code>switch</code> statement on the enum. Each case of that statement
calls a handler method for the respective command.
Whatever else the args interpreter does, it calls here to execute a command.
That's all you need to know about it to get started.
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="test-local"><span>Testing <code>local</code></span></h2>

<p>
Execute the command and study the output:
</p>
<div><code>&nbsp;&nbsp;java -jar tutorial.jar local</code></div>
<p>
Connect your computer to different networks (wired, WiFi, VPN) and repeat.
</p>


<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="test-islocal"><span>Testing <code>islocal</code></span></h2>

<p>
Execute the command with different hostname arguments:
</p>
<div><code>&nbsp;&nbsp;java -jar tutorial.jar islocal <i>hostname</i></code></div>
<p>
Some arguments to try:
</p>
<ul>
<li>
  Hostnames and IP addresses printed by the <code>islocal</code> command.
  These should be recognized as local addresses.
</li>
<li>
  Hostnames of internet sites, such as 'example.com', or other computers.
  These should be recognized as non-local addresses.
</li>
</ul>
<p>
If these arguments are not recognized as expected, your code is still buggy.
</p>

<p>
When the command is working as expected, play around some more. Can you
find local hostnames that are not printed by the <code>local</code> command?
For example, try your computer's name without a domain, or with
domain '.local'. What about other IP addresses, like '127.0.0.8'?
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="test-lookup"><span>Testing <code>lookup</code></span></h2>

<p>
Execute the command with different hostname arguments:
</p>
<div><code>&nbsp;&nbsp;java -jar tutorial.jar lookup <i>hostname</i></code></div>
<p>
Here are some arguments to try, with expected output.
Some of them require an internet connection for the lookup.
</p>
<ul>
<li>localhost &nbsp;-&nbsp;
  a subset of the output from the <code>local</code> command</li>
<li>nowhere.invalid &nbsp;-&nbsp; no address at all</li>
<li>numeric IPv4 and IPv6 addresses &nbsp;-&nbsp; the argument address
<!-- lookups performed on 2018-09-20: -->
<li>apache.org &nbsp;-&nbsp; two different IPv4 addresses</li>
<li>gnu.org &nbsp;-&nbsp; both an IPv4 and an IPv6 address</li>
</ul>

<p>
Perform some more lookups of your own.
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="help-islocal"><span>Spoiler: Fixing <code>islocal</code></span></h2>

<p>
<i>
Sorry, not written yet. Old content for re-use:
</i>
</p>

<div class="code">
  Missing.here("bind a socket to a hostname");
  Missing.pretend(IOException.class);
</div>

<p>
Before you can fix anything, you have to understand what is going on
in that part of the code. The references to class <code>Missing</code>
are exactly where you'll have to put in your own code. The message,
'bind a socket to a hostname', tells you what is missing.
But unless you are familiar with the socket API, this message is unclear.
The call to <code>Missing.pretend</code> indicates that the missing code
may throw an <code>IOException</code>.
</p>

<p>
When a method is so small as <code>handleIsLocalCmd</code>, you should try
to understand it fully. There is a description, which you can read in the
source code as well as in the
<a href="jdoc/index.html" target="_blank">JavaDocs</a>.
The method is expected to return 0 if the argument is the local host,
or -1 if it is not. In the method body, there is some error handling code.
If the missing code runs through, the method returns 0.
If it throws an <code>IOException</code>, the method returns -1.
Before that, the string argument is converted into an
<code>InetSocketAddress</code>.
Let's summarize:
</p>
<ol>
<li>You have a hostname,
  already converted to <code>InetSocketAddress</code>.</li>
<li>The missing code should run through if the hostname is local.</li>
<li>The missing code should throw an <code>IOException</code>
  if the hostname is not local.</li>
<li>The missing code should 'bind' a 'socket' to the hostname.</li>
</ol>

<p>
Now it is time to study the standard Java APIs. There are JavaDocs available:
online, for download, or maybe already installed with your JDK or IDE.
Pick whichever is most convenient for you.
The <code>InetSocketAddress</code> is a place to start. Look for the
import statements at the beginning of 'TutorialCommandHandler.java'.
From which package is that class?
What other classes are imported from there?
Anything related to 'bind' or 'socket'?
Bingo, there's an import of <code>java.net.Socket</code>.
<a href="http://lmgtfy.com/?q=javadoc+InetSocketAddress+java.net.Socket"
   class="covert"
   >Search</a> and browse the JavaDocs for these two classes.
Is there something about 'bind'?
Can you do that with an <code>InetSocketAddress</code>?
Does it make a difference whether the hostname is local?
</p>

<p>
When you have found and assimilated that information, put in the missing code:
<br/>
Delete the calls to class <code>Missing</code>.
Create an unconnected socket. Bind that socket to the hostname.
That's it. <span class="emph">Maybe</span>.
To be sure, you need to test your changes.
</p>



<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
<h2 id="help-lookup"><span>Spoiler: Fixing <code>lookup</code></span></h2>

<p>
<i>
Sorry, not written yet. Old content for re-use:
</i>
</p>

<p>
The helper expects objects of class <code>InetAddress</code>.
From what package is that class? Browse its JavaDocs.
Any hints on how to obtain such objects?
From a hostname, which is the only input you have?
There are different methods you could call, which is the right one?
If you're not sure, go back to where the code is missing,
read the description and comments again.
</p>

<p>
OK, you've got all the pieces of the puzzle now. It is time to write code.
Remove calls to class <code>Missing</code>.
Put in code that looks up the internet addresses for the hostname.
Implement a loop that prints them, using the helper method.

Is there a problem when compiling?
Handle the exception that might be thrown by the lookup.
The user should know when that fails.
</p>

<div class="back-link">
<a onclick="history.back();">Back to the Tutorial</a>
</div>


</body>
</html>

